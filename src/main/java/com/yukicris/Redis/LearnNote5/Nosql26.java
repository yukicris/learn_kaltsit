package com.yukicris.Redis.LearnNote5;

public class Nosql26 {
    //缓存穿透和雪崩
    //高频面试,工作常用

    //此处不会分析其底层解决方案


    //客户端读请求先去缓存中查询,如果缓存中没有,就会去数据库中查询
    //如果这个时候,一个攻击,或者说用户查询一个数据库和缓存中都没有的数据,那么他就会频繁的请求数据库,这就是缓存穿透
    /**
     * 缓存穿透(查不到导致的)
     *
     * 缓存穿透的概念很简单,用户想要查询一个数据,发现redis内存数据库没有,也就是缓存没有命中,于是向持久层数据库查询,
     * 发现也没有,于是本次查询失败,当用户很多的时候,缓存都没有命中(秒杀场景),于是都去请求了持久层数据库,就会给持久层数据库造成很大压力,
     * 这个时候就相当于出现了缓存穿透
     *
     *
     * 解决方案: 1 布隆过滤器(BloomFilter) 他是一种数据结构,对所有可能查询的参数以hash形式进行存储,在控制层进行校验(在查询缓存之前执行过滤),不符合就丢弃,从而避免了对底层
     * 查询系统的压力
     *          2 缓存空对象 当存储层不命中后,即使返回的空对象也将其缓存起来,同时会设置一个过期时间,之后在访问这个数据就会从缓存中进行读取,保护了后端数据源
     * 这种方式的缺点是空值存储会导致缓存需要更多的空间存储更多的键,即使对空值设置了过期时间,也会对缓存层和存储层的数据有一段时间的不一致,对于需要保持一致性的业务会有影响
     */


    /**
     * 缓存击穿(量太大,缓存过期)
     *
     * 缓存击穿是指一个key非常热点,不停的扛着大并发,大并发集中对这一个点进行访问,当这个key在失效的瞬间,持续的大并发就穿破缓存,直接请求数据库,就像在一个屏障上凿开了一个洞
     * 当某个key过期的瞬间,有大量的并发请求访问,这类数据一般是热点数据,由于缓存过期,会同时访问数据库来查询最新的数据,并且回写缓存,导致数据库瞬间压力过大
     *
     * 解决方法: 1 设置热点数据永不过期
     *         2  加互斥锁  分布式锁: 使用分布式锁,保证每个key同时只有一个线程去查询后端服务,其他线程没有获得分布式锁的权限,因此只要等待即可,这种方式将高并发的压力转移到了分布式锁
     *         对分布式锁的考验很大
     */


    /**
     * 缓存雪崩
     *
     * 某一个时间段,缓存集中过期失效,redis宕机
     * 比如双11零点,马上会有一波抢购,这波商品比较集中的放入了缓存,假设缓存一个小时,到了凌晨1点的时候,这批商品缓存过期,那么对于这批商品的访问查询全落到了数据库上,对于数据库而言,就会产生
     * 周期性的压力波峰,于是所有的请求都会达到存储层,存储层的调用量会暴增,造成存储层挂掉的情况
     *
     * 集中过期可能不会非常致命,但是如果是某个缓存节点宕机了或者断网了,那么压力就无法预知了,可能瞬间把数据库压垮
     *
     * 解决方案: 1 redis高可用: 既然redis可能挂掉,那么我多增设几台redis,这样一台挂掉还有其他几台redis继续工作,其实就是搭建集群
     * 2 限流降级(类似Hystrix) : 在缓存失效以后,通过加锁或者队列来控制数据库写缓存的线程数量,比如某个key只允许一个线程的查询和写缓存,其他的线程等待
     * 3 数据预热: 在正式部署以前,把可能的数据先预先访问一遍,这样部分可能大量访问的数据都加载到缓存中,在即将发生的大并发访问前手动触发加载不同的key,设置不同的过期时间,让缓存失效的时间点尽量均匀
     *
     *
     */





}
