package com.yukicris.JVM.java3;

public class day7 {
    //JMM
    //java内存模型
    // 它干嘛的: 缓存一致性协议,定义数据读写的规则(8种)
    // JMM定义了线程工作内存和主内存之间的抽象关系,线程之间的共享变量存储在主内存中(Main Memory),每个线程都有一个私有内存(local Memory)
       //电脑有一个主内存 然后每个线程都有自己的私有内存,是从主内存中拷贝的,但是数据不一定会与主内存一致会被人改变,但是这个数据并没有同步到主存中
       //voliate关键字保证这个数据的可见性,让这个改变的参数马上刷新到主内存中





    //什么是voliate关键字
   /* 一、内存可见性

    基于缓存一致性协议，当用voliate关键字修饰的变量改动时，cpu会通知其他线程，缓存已被修改，需要更新缓存。这样每个线程都能获取到最新的变量值。
    二、基于内存屏障的防止指令重排
    用voliate修饰的变量，可以防止cpu指令重排序。底层的实现方式是基于4种内存屏障：读读、读写、写读、读读屏障。
    由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。
*/

/**    JMM即为JAVA 内存模型（java memory model），JMM规定了内存主要划分为主内存和工作内存两种。主内存对应的是Java堆中的对象实例部分，工作内存对应的是栈中的部分区域。每条线程拥有各自的工作内存，工作内存中的变量是主内存中的一份拷贝。

    二、JMM的八种交互操作（每个操作都为原子操作）
    lock （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态
    unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
    read （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
    load （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中
    use （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令
    assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中
    store （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用
    write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中

**

    三、对八种操作的规则
    不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write
    不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存
    不允许一个线程将没有assign的数据从工作内存同步回主内存
    一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作
    一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁
    如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值
    如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量
    对一个变量进行unlock操作之前，必须把此变量同步回主内存
**

    四、volatile
    volatile在java语言中是一个关键字，用于修饰变量。被volatile修饰的变量后，表示这个变量在不同线程中是共享，编译器与运行时都会注意到这个变量是共享的，因此不会对该变量进行重排序。
    volatile关键字保证可见性、有序性。但不保证原子性。
            　volatile boolean isStop = false;

    volatile int a = 1;             //用volatile修饰变量
1
        《深入理解Java虚拟机》中有一句话：“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”，lock前缀指令生成一个内存屏障。保证重排序后的指令不会越过内存屏障，即volatile之前的代码只会在volatile之前执行，volaiter之后的代码只会在volatile之后执行。
            ————————————————
    版权声明：本文为CSDN博主「Bang tidy」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
    原文链接：https://blog.csdn.net/Bangtidy/article/details/107493436*/
}