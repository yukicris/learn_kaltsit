package com.yukicris.JVM.java3;

public class day6 {
    //GC
    //GC的作用区域本质是在方法区(其实也是在堆中[元数据])和堆中
    //JVM在进行GC时,并不是对这三个区域进行统一回收,大部分时候,回收都是新生代
    //-新生代
    //-幸存区 (from ,to)-谁空谁是to,把对象复制移动到to里面去,就变成from了,空的就变成to了
    //-老年区

    //GC两种类: 轻GC(普通GC), 重GC(全局GC)

    /**
     * JVM内存模型和分区,详细到每个区放什么?
     *
     *
     * 堆里面的分区有哪些? Eden 占8 ,From占1, to占1 一般是8/1/1, 老年区
     *
     *
     * GC算法有哪些? 标记清除法  标记整理法(或者叫标记压缩) 复制算法 分代收集法 (引用计数法这个没用了)
     * 可以看这个4分钟小动画 https://www.bilibili.com/video/BV1PW4y1J7VY/?spm_id_from=333.337.search-card.all.click&vd_source=240bc6288b8bd53454a480f0c5e8e3e7
     *    1 每次GC都会把Eden的对象移动到幸存区,一旦Eden区被GC后,就会是空的 2 复制算法会把from中的这个对象复制到to里面,同时会把eden的存活对象放到to里面,这个to就变成了from,from空了就变成了to,谁空谁是to,然后在下次gc时看它活着哪些,
     *    复制到to里面,清理掉from里面的死的,from就空出来了,就变成了to
     *    3 一个对象经历了15次GC,还没有死,就要从幸存区from进入老年代进行重GC(全局gc)了,,-XX:MaxTenuringThreshold=5 (最大任期(存活)时间) 通过这个参数可以设定进入老年代的时间,默认是15
     *    //复制算法的好处就是没有内存的碎片,坏处就是浪费很多内存空间,多了一半空间永远是空to, 如果假设对象100%存活,(极端情况)就会让from耗费大量空间
     *
     *
     *    一般轻GC都是复制算法,因为年轻代(新生区)很多对象招生夕死,存活下来的很少,因为复制算法需要在gc的时候把存活的对象复制到另一个空间中,然后把当前的区域清空(即from变成to),因为存活的少,占用的空间也少,适合复制算法
     * 轻GC和重GC分别在什么时候发生?
     *
     */

    // 标记清除算法 ,会把存活的对象标记出来,然后同一回收所有未被标记的对象(一般选择这种)也可以反过来,标记所有需要回收的对象,标记完成后统一回收
    //优点:对比复制算法不需要额外的空间
    //缺点是效率问题(如果标记的对象太多,效率会很低,2次扫描一次标记一次清理影响效率)  空间问题(标记清除后,会产生大量不连续的内存碎片)

    //标记整理算法
    //类似标记清除算法,不过在标记完毕后会把所有的标记存活内容向内存的一个方向移动,然后把存活一端内存以外的地方清除掉
    //优点是消除了标记清除算法中内存区域分散的缺点,需要给新对象分配内存时JVM只需要维持一个内存的起始地址即可;并且消除了复制算法中内存减半的代价
    //缺点 1效率要低于复制算法,而且比标记清除算法也多了一次移动扫描 2从移动对象的同时,如果对象被其他对象引用,需要调整引用的地址  3 移动过程中,需要全程暂停用户应用程序


    //引用计数法为什么没用了 ,它的原理是在每个对象上面有标记引用次数,然后在gc的时候把引用次数为0的淘汰掉,
    //这个计数器本身也会有消耗,在跑死循环一类的时候这个计数器会占用大量内存,所以这种不常用了


    // 内存效率 复制算法(一次)>标记清除算法(扫描2次)>标记压缩算法(扫描3次)  (时间复杂度)
    // 内存整齐度: 复制算法=标记压缩算法>标记清除算法
    // 内存利用率: 标记压缩算法=标记清除算法>复制算法

    //没有最好的算法,只有最合适的算法

    //年轻代 存活率低,复制算法
    //老年代 存活率高,区域大,标记清除+标记压缩混合实现(需要人考虑多少次进行标记清除,比如内存碎片不多,就多用标记清除)
}
