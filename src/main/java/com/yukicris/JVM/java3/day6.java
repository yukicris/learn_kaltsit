package com.yukicris.JVM.java3;

public class day6 {
    //GC
    //GC的作用区域本质是在方法区(其实也是在堆中[元数据])和堆中
    //JVM在进行GC时,并不是对这三个区域进行统一回收,大部分时候,回收都是新生代
    //-新生代
    //-幸存区 (from ,to)-谁空谁是to,把对象复制移动到to里面去,就变成from了,空的就变成to了
    //-老年区

    //GC两种类: 轻GC(普通GC), 重GC(全局GC)

    /**
     * JVM内存模型和分区,详细到每个区放什么?
     *
     *
     * 堆里面的分区有哪些? Eden 占8 ,From占1, to占1 一般是8/1/1, 老年区
     *
     *
     * GC算法有哪些? 标记清除法  标记整理法(或者叫标记压缩) 复制算法 分代收集法 (引用计数法这个没用了)
     * 可以看这个4分钟小动画 https://www.bilibili.com/video/BV1PW4y1J7VY/?spm_id_from=333.337.search-card.all.click&vd_source=240bc6288b8bd53454a480f0c5e8e3e7
     *    1 每次GC都会把Eden的对象移动到幸存区,一旦Eden区被GC后,就会是空的 2 复制算法会把from中的这个对象复制到to里面,同时会把eden的存活对象放到to里面,这个to就变成了from,from空了就变成了to,谁空谁是to,然后在下次gc时看它活着哪些,
     *    复制到to里面,清理掉from里面的死的,from就空出来了,就变成了to
     *    3 一个对象经历了15次GC,还没有死,就要从幸存区from进入老年代进行重GC(全局gc)了,,-XX:MaxTenuringThreshold=5 (最大任期(存活)时间) 通过这个参数可以设定进入老年代的时间,默认是15
     *    //复制算法的好处就是没有内存的碎片,坏处就是浪费很多内存空间,多了一半空间永远是空to, 如果假设对象100%存活,(极端情况)就会让from耗费大量空间
     *
     *
     *    一般轻GC都是复制算法,因为年轻代(新生区)很多对象招生夕死,存活下来的很少,因为复制算法需要在gc的时候把存活的对象复制到另一个空间中,然后把当前的区域清空(即from变成to),因为存活的少,占用的空间也少,适合复制算法
     * 轻GC和重GC分别在什么时候发生?
     *
     */

    // 标记清除算法 ,会把存活的对象标记出来,然后同一回收所有未被标记的对象(一般选择这种)也可以反过来,标记所有需要回收的对象,标记完成后统一回收
    //优点:对比复制算法不需要额外的空间
    //缺点是效率问题(如果标记的对象太多,效率会很低,2次扫描一次标记一次清理影响效率)  空间问题(标记清除后,会产生大量不连续的内存碎片)

    //标记整理算法
    //类似标记清除算法,不过在标记完毕后会把所有的标记存活内容向内存的一个方向移动,然后把存活一端内存以外的地方清除掉
    //优点是消除了标记清除算法中内存区域分散的缺点,需要给新对象分配内存时JVM只需要维持一个内存的起始地址即可;并且消除了复制算法中内存减半的代价
    //缺点 1效率要低于复制算法,而且比标记清除算法也多了一次移动扫描 2从移动对象的同时,如果对象被其他对象引用,需要调整引用的地址  3 移动过程中,需要全程暂停用户应用程序


    //引用计数法为什么没用了 ,它的原理是在每个对象上面有标记引用次数,然后在gc的时候把引用次数为0的淘汰掉,
    //这个计数器本身也会有消耗,在跑死循环一类的时候这个计数器会占用大量内存,所以这种不常用了


    // 内存效率 复制算法(一次)>标记清除算法(扫描2次)>标记压缩算法(扫描3次)  (时间复杂度)
    // 内存整齐度: 复制算法=标记压缩算法>标记清除算法
    // 内存利用率: 标记压缩算法=标记清除算法>复制算法

    //没有最好的算法,只有最合适的算法

    //年轻代 存活率低,复制算法
    //老年代 存活率高,区域大,标记清除+标记压缩混合实现(需要人考虑多少次进行标记清除,比如内存碎片不多,就多用标记清除)



   /* 方法区：（逻辑上）

    逻辑上的东西，是JVM 的规范，所有虚拟机必须遵守的。

    是JVM 所有线程共享的、用于存储类的信息、常量池、方法数据、方法代码等。

    永久代：（方法区的实现、JDK7及之前、主要是和元空间对比）

    PermGen ， 就是 PermGen space ，全称是 Permanent Generation space ，是指内存的永久保存区域。

    PermGen space 则是 HotSpot 虚拟机基于JVM规范对方法区的一个落地实现，并且只有 HotSpot 才有 PermGen space。
    而如 JRockit（Oracle）、J9（IBM） 虚拟机有方法区 ，但是就没有 PermGen space。
    PermGen space 是JDK7及之前， HotSpot虚拟机对方法区的一个落地实现。在JDK8被移除。‘
    Metaspace（元空间、JDK8及之后）：

    元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。

    移除PermGen（永久代）从从JDK7 就开始。例如，字符串内部池，已经在JDK7 中从永久代中移除。直到JDK8 的发布将宣告 PermGen（永久代）的终结。
    其实，移除 PermGen 的工作从 JDK7 就开始，永久代的部分数据就已经转移到了 Java Heap 或者是 Native Heap。
    但永久代仍存在于JDK7 中，并没完全移除，比如：
    字面量 （interned strings）转移到 Java heap；
    类的静态变量（class statics）转移到Java heap ；
    符号引用（Symbols） 转移到 Native heap ；
    JDK版本	方法区的实现	运行时常量池所在的位置
    JDK6	PermGen space（永久代）	PermGen space（永久代）
    JDK7	PermGen space（永久代）	Heap（堆）
    JDK8	Metaspace（元空间）	Heap（堆）
    JDK6、JDK7 时，方法区 就是 PermGen（永久代）。
    JDK8 时，方法区就是 Metaspace（元空间）。

    这篇文章写的很好：JVM之 方法区、永久代（PermGen space）、元空间（Metaspace）三者的区别



    为什么使用元空间替换永久代？

    表面上看是为了避免OOM异常。

    因为通常使用PermSize和MaxPermSize设置永久代的大小就决定了永久代的上限，但是不是总能知道应该设置为多大合适, 如果使用默认值很容易遇到OOM错误。

    当使用元空间时，可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制。

    更深层的原因还是要合并HotSpot和JRockit的代码，JRockit从来没有所谓的永久代，也不需要开发运维人员设置永久代的大小，但是运行良好。同时也不用担心运行性能问题了,在覆盖到的测试中, 程序启动和运行速度降低不超过1%，但是这点性能损失换来了更大的安全保障。

    由于永久代内存经常不够用或者发生内存泄露，爆出异常 java.lang.OutOfMemoryError: PermGen 。
    字符串存在永久代中，容易出现性能问题和内存溢出。
    类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
    永久代会位GC带来不必要的复杂度，而且回收效率偏低。
    Oracle可能会将HotSpot和JRockit合二为一。
            ————————————————
    版权声明：本文为CSDN博主「沐雨金鳞」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
    原文链接：https://blog.csdn.net/qq_38262266/article/details/107208357*/
}
