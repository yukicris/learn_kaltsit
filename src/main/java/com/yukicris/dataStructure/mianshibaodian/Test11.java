package com.yukicris.dataStructure.mianshibaodian;

public class Test11 {
    //给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。
    // 请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
    //
    //2 <= n <= 1000

    //区别在于n的作用域变成了1000,所以乘积可能会非常大..一般称为大数运算,可能会导致int 越界,long也不一定够

    //用贪心算法,不太好写,但是基本上是对3取模,3种情况,余1,余2和整除

    //用官方的循环取余法,不太能理解
    public int cuttingRope(int n) {
        if(n<=3) return n-1;  //n为2或3乘积只有1或2最大
        int b = n%3;  //对3取模
        int p=1000000007; //极限值

// n = 3a+b
//   b = 0,返回3的a次方
//   b = 1,要把一个3转换成3+1,即2乘以2 ,返回 3的a-1次方乘以2的2次方
//   b = 2,返回3的a次方乘以2

        long rem = 1, x = 3;
        //b=2的情况
        for (int a = n/3 - 1;a>0;a/=2){  //1000/3=333,减一为332段,332段对2 取整,
            if (a%2==1) {
                rem = (rem*x)%p;
            }
            x = (x*x)%p;
        }
        if(b == 0) return (int)(rem * 3 % p);
        if(b == 1) return (int)(rem * 4 % p);

        return (int)(rem * 6 % p);
    }

}
