package com.yukicris.Thread.ThreadDay7;

public class Knowledge2 {
    //java 提供了几个方法解决了线程之间通信问题
    /**
     * wait()   表示线程会一直等待,直到其他的线程通知,与sleep不同,它会释放锁
     * ps : sleep()方法是Thread的静态方法，而wait是Object实例方法
     * wait()方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。而sleep()方法没有这个限制可以在任何地方种使用。另外，wait()方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出CPU并不会释放掉对象锁；
     * sleep()方法在休眠时间达到后如果再次获得CPU时间片就会继续执行，而wait()方法必须等待Object.notift/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行。
     * 通俗说,就是sleep我醒了我马上又锁住了,别人占不过我,sleep时间就很准,而wait只是进入等待池,还要再次去争取cpu资源
     * 另外需要注意的是，sleep()和yield()方法，同样都是当前线程会交出处理器资源，而它们不同的是，sleep()交出来的时间片其他线程都可以去竞争，也就是说都有机会获得当前线程让出的时间片。而yield()方法只允许与当前线程具有相同优先级的线程能够获得释放出来的CPU时间片。
     *
     *
     * wait(long timeout) 指定等待的毫秒数
     *
     * notify()  唤醒一个处于等待状态的线程
     *
     * notifyall() 唤醒同一个对象上所有调用wait()方法的线程,优先级别高的线程优先调度
     *
     * 注意: 都是Object类的方法,都只能在同步方法或者同步代码块中使用,否则会抛出异常
     * ILLegalMonitorStateException
     */


    //并发协作模型, "生产者/消费者模式" -->管程法
    /**
     * 生产者: 负责生产数据的模块  (可能是方法,对象,线程,进程)
     * 消费者: 负责处理数据的模块  (可能是方法,对象,线程,进程)
     * 缓冲区: 消费者不能直接使用生产者的数据,他们之间有个缓冲区
     *
     *
     * 生产者将生产好的数据放入缓冲区,消费者从缓冲区拿出数据
     *
     */

    //自旋锁
    //当一个线程尝试去获取某一把锁的时候，
    // 如果这个锁已经被另外一个线程占有了，那么此线程就无法获取这把锁，该线程会等待，间隔一段时间后再次尝试获取。
    // 这种采用循环加锁,等待锁释放的机制就称为自旋锁（spinlock）


    // CAS又称 自旋锁、无锁，是一种乐观锁
    /*ompare and swap 的缩写 意为: 比较并交换 ,
    实现并发算法的常用技术 , 就是说我不用加锁 , 也能保证 ( 加锁会影响效率，可以考虑使用原子操作类 )  原子性 ,
    当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，
    失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试 , 因此可以知道 , CAS只会允许一个线程的执行成功
    CAS 包括三个操作数 - 内存位置 , 预期原值以及更新值
    执行 CAS 操作的时候,将内存位置的值与预期原值比较
            如果相匹配 , 那么处理器会自动的将该位置更新为新值
    如果不匹配 , 处理器不做任何操作 , 多个线程同时执行 CAS 的操作只有一个成功*/

    //
}
